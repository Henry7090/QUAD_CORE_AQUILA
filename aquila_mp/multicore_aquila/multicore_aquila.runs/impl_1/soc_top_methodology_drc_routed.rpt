Copyright 1986-2022 Xilinx, Inc. All Rights Reserved. Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.
-----------------------------------------------------------------------------------------------------------------------------------------------------------
| Tool Version : Vivado v.2024.1 (lin64) Build 5076996 Wed May 22 18:36:09 MDT 2024
| Date         : Sat Oct  5 14:46:30 2024
| Host         : henry7090-ROG-Zephyrus-G16 running 64-bit Ubuntu 24.04.1 LTS
| Command      : report_methodology -file soc_top_methodology_drc_routed.rpt -pb soc_top_methodology_drc_routed.pb -rpx soc_top_methodology_drc_routed.rpx
| Design       : soc_top
| Device       : xc7a100tcsg324-1
| Speed File   : -1
| Design State : Fully Routed
-----------------------------------------------------------------------------------------------------------------------------------------------------------

Report Methodology

Table of Contents
-----------------
1. REPORT SUMMARY
2. REPORT DETAILS

1. REPORT SUMMARY
-----------------
            Netlist: netlist
          Floorplan: design_1
      Design limits: <entire design considered>
             Max violations: <unlimited>
             Violations found: 151
+-----------+----------+-----------------------------------------------------------+------------+
| Rule      | Severity | Description                                               | Violations |
+-----------+----------+-----------------------------------------------------------+------------+
| LUTAR-1   | Warning  | LUT drives async reset alert                              | 5          |
| SYNTH-5   | Warning  | Mapped onto distributed RAM because of timing constraints | 64         |
| SYNTH-10  | Warning  | Wide multiplier                                           | 8          |
| SYNTH-15  | Warning  | Byte wide write enable not inferred                       | 32         |
| TIMING-20 | Warning  | Non-clocked latch                                         | 22         |
| XDCB-5    | Warning  | Runtime inefficient way to find pin objects               | 3          |
| LATCH-1   | Advisory | Existing latches in the design                            | 1          |
| REQP-1959 | Advisory | connects_SERDES_RST_driver_not_FF                         | 16         |
+-----------+----------+-----------------------------------------------------------+------------+

2. REPORT DETAILS
-----------------
LUTAR-1#1 Warning
LUT drives async reset alert  
LUT cell MIG/u_mig_7series_0_mig/u_iodelay_ctrl/rstdiv2_sync_r[11]_i_1, with 2 or more inputs, drives asynchronous preset/clear pin(s) MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r1_reg_rep__7/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r1_reg_rep__8/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r1_reg_rep__9/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[0]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[10]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[11]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[1]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[2]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[3]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[4]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[5]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[6]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[7]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[8]/PRE,
MIG/u_mig_7series_0_mig/u_ddr3_infrastructure/rstdiv0_sync_r_reg[9]/PRE
 (the first 15 of 32 listed). The LUT may glitch and trigger an unexpected reset, even if it is a properly timed path.
Related violations: <none>

LUTAR-1#2 Warning
LUT drives async reset alert  
LUT cell dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.gwrrd_rst_sync_stage[2].rrst_inst/ngwrdrst.grst.g7serrst.rd_rst_reg[2]_i_1, with 2 or more inputs, drives asynchronous preset/clear pin(s) dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.rd_rst_reg_reg[0]/PRE,
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1]/PRE
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2]/PRE. The LUT may glitch and trigger an unexpected reset, even if it is a properly timed path.
Related violations: <none>

LUTAR-1#3 Warning
LUT drives async reset alert  
LUT cell dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.gwrrd_rst_sync_stage[2].wrst_inst/ngwrdrst.grst.g7serrst.wr_rst_reg[2]_i_1, with 2 or more inputs, drives asynchronous preset/clear pin(s) dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.wr_rst_reg_reg[0]/PRE,
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.wr_rst_reg_reg[1]/PRE
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_RD/U_RD_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_rdfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.wr_rst_reg_reg[2]/PRE. The LUT may glitch and trigger an unexpected reset, even if it is a properly timed path.
Related violations: <none>

LUTAR-1#4 Warning
LUT drives async reset alert  
LUT cell dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.gwrrd_rst_sync_stage[2].rrst_inst/ngwrdrst.grst.g7serrst.rd_rst_reg[2]_i_1, with 2 or more inputs, drives asynchronous preset/clear pin(s) dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.rd_rst_reg_reg[0]/PRE,
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1]/PRE
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2]/PRE. The LUT may glitch and trigger an unexpected reset, even if it is a properly timed path.
Related violations: <none>

LUTAR-1#5 Warning
LUT drives async reset alert  
LUT cell dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.gwrrd_rst_sync_stage[2].wrst_inst/ngwrdrst.grst.g7serrst.wr_rst_reg[2]_i_1, with 2 or more inputs, drives asynchronous preset/clear pin(s) dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.wr_rst_reg_reg[0]/PRE,
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.wr_rst_reg_reg[1]/PRE
dbg_hub/inst/BSCANID.u_xsdbm_id/CORE_XSDB.UUT_MASTER/U_ICON_INTERFACE/U_CMD6_WR/U_WR_FIFO/SUBCORE_FIFO.xsdbm_v3_0_2_wrfifo_inst/inst_fifo_gen/gconvfifo.rf/grf.rf/rstblk/ngwrdrst.grst.g7serrst.wr_rst_reg_reg[2]/PRE. The LUT may glitch and trigger an unexpected reset, even if it is a properly timed path.
Related violations: <none>

SYNTH-5#1 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#2 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#3 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#4 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#5 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#6 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#7 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#8 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[0].VALID_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#9 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#10 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#11 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#12 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#13 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#14 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#15 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#16 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[1].VALID_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#17 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#18 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#19 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#20 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#21 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#22 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#23 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#24 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[2].VALID_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#25 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#26 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#27 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#28 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#29 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#30 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#31 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#32 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk5[3].VALID_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#33 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#34 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#35 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#36 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#37 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#38 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#39 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#40 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[0].DIRTY_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#41 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#42 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#43 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#44 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#45 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#46 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#47 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#48 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[1].DIRTY_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#49 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#50 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#51 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#52 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#53 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#54 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#55 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#56 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[2].DIRTY_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#57 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r1_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#58 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r1_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#59 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r1_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#60 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r1_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#61 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r2_0_127_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#62 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r2_128_255_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#63 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r2_256_383_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-5#64 Warning
Mapped onto distributed RAM because of timing constraints  
The instance L2_Cache/genblk6[3].DIRTY_RAM/RAM_reg_r2_384_511_0_0 is implemented as distributed LUT RAM for the following reason: The timing constraints suggest that the chosen mapping will yield a better timing.
Related violations: <none>

SYNTH-10#1 Warning
Wide multiplier  
Detected multiplier at genblk1[0].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul00 of size 16x18, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-10#2 Warning
Wide multiplier  
Detected multiplier at genblk1[0].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul00__0 of size 18x18, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-10#3 Warning
Wide multiplier  
Detected multiplier at genblk1[0].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul0_reg of size 16x16, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-10#4 Warning
Wide multiplier  
Detected multiplier at genblk1[0].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul0_reg__0 of size 18x16, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-10#5 Warning
Wide multiplier  
Detected multiplier at genblk1[1].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul00 of size 16x18, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-10#6 Warning
Wide multiplier  
Detected multiplier at genblk1[1].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul00__0 of size 18x18, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-10#7 Warning
Wide multiplier  
Detected multiplier at genblk1[1].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul0_reg of size 16x16, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-10#8 Warning
Wide multiplier  
Detected multiplier at genblk1[1].Aquila_SoC/RISCV_CORE/Execute/MulDiv/mul0_reg__0 of size 18x16, it is decomposed from a wide multipler into 4 DSP blocks.
Related violations: <none>

SYNTH-15#1 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_0_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#2 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_0_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#3 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_0_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#4 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_0_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#5 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_1_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#6 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_1_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#7 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_1_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#8 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_1_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#9 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_2_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#10 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_2_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#11 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_2_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#12 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_2_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#13 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_3_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#14 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_3_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#15 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_3_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#16 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[0].Aquila_SoC/TCM/RAM_reg_3_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#17 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_0_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#18 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_0_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#19 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_0_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#20 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_0_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#21 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_1_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#22 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_1_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#23 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_1_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#24 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_1_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#25 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_2_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#26 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_2_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#27 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_2_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#28 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_2_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#29 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_3_0 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#30 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_3_1 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#31 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_3_2 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

SYNTH-15#32 Warning
Byte wide write enable not inferred  
Byte wide write enable (BWWE) is not inferred for Block RAM genblk1[1].Aquila_SoC/TCM/RAM_reg_3_3 because address width (14) is more than optimal threshold of 12. Implementing using BWWE will require more logic and timing would be suboptimal. Please use attribute ram_decomp = power if BWWE is desired..
Related violations: <none>

TIMING-20#1 Warning
Non-clocked latch  
The latch Amo_arbiter/FSM_onehot_n_state_reg[0] cannot be properly analyzed as its control pin Amo_arbiter/FSM_onehot_n_state_reg[0]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#2 Warning
Non-clocked latch  
The latch Amo_arbiter/FSM_onehot_n_state_reg[1] cannot be properly analyzed as its control pin Amo_arbiter/FSM_onehot_n_state_reg[1]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#3 Warning
Non-clocked latch  
The latch Amo_arbiter/FSM_onehot_n_state_reg[2] cannot be properly analyzed as its control pin Amo_arbiter/FSM_onehot_n_state_reg[2]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#4 Warning
Non-clocked latch  
The latch Device_arbiter/FSM_onehot_n_state_reg[0] cannot be properly analyzed as its control pin Device_arbiter/FSM_onehot_n_state_reg[0]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#5 Warning
Non-clocked latch  
The latch Device_arbiter/FSM_onehot_n_state_reg[1] cannot be properly analyzed as its control pin Device_arbiter/FSM_onehot_n_state_reg[1]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#6 Warning
Non-clocked latch  
The latch Device_arbiter/FSM_onehot_n_state_reg[2] cannot be properly analyzed as its control pin Device_arbiter/FSM_onehot_n_state_reg[2]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#7 Warning
Non-clocked latch  
The latch Memory_Arbiter/FSM_onehot_n_state_reg[0] cannot be properly analyzed as its control pin Memory_Arbiter/FSM_onehot_n_state_reg[0]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#8 Warning
Non-clocked latch  
The latch Memory_Arbiter/FSM_onehot_n_state_reg[0]_rep cannot be properly analyzed as its control pin Memory_Arbiter/FSM_onehot_n_state_reg[0]_rep/G is not reached by a timing clock
Related violations: <none>

TIMING-20#9 Warning
Non-clocked latch  
The latch Memory_Arbiter/FSM_onehot_n_state_reg[1] cannot be properly analyzed as its control pin Memory_Arbiter/FSM_onehot_n_state_reg[1]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#10 Warning
Non-clocked latch  
The latch Memory_Arbiter/FSM_onehot_n_state_reg[2] cannot be properly analyzed as its control pin Memory_Arbiter/FSM_onehot_n_state_reg[2]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#11 Warning
Non-clocked latch  
The latch Memory_Arbiter/FSM_onehot_n_state_reg[3] cannot be properly analyzed as its control pin Memory_Arbiter/FSM_onehot_n_state_reg[3]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#12 Warning
Non-clocked latch  
The latch Memory_Arbiter/FSM_onehot_n_state_reg[4] cannot be properly analyzed as its control pin Memory_Arbiter/FSM_onehot_n_state_reg[4]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#13 Warning
Non-clocked latch  
The latch genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[0] cannot be properly analyzed as its control pin genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[0]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#14 Warning
Non-clocked latch  
The latch genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[1] cannot be properly analyzed as its control pin genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[1]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#15 Warning
Non-clocked latch  
The latch genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[2] cannot be properly analyzed as its control pin genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[2]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#16 Warning
Non-clocked latch  
The latch genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[3] cannot be properly analyzed as its control pin genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[3]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#17 Warning
Non-clocked latch  
The latch genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[4] cannot be properly analyzed as its control pin genblk1[0].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[4]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#18 Warning
Non-clocked latch  
The latch genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[0] cannot be properly analyzed as its control pin genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[0]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#19 Warning
Non-clocked latch  
The latch genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[1] cannot be properly analyzed as its control pin genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[1]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#20 Warning
Non-clocked latch  
The latch genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[2] cannot be properly analyzed as its control pin genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[2]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#21 Warning
Non-clocked latch  
The latch genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[3] cannot be properly analyzed as its control pin genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[3]/G is not reached by a timing clock
Related violations: <none>

TIMING-20#22 Warning
Non-clocked latch  
The latch genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[4] cannot be properly analyzed as its control pin genblk1[1].Aquila_SoC/I_Cache/FSM_onehot_S_nxt_reg[4]/G is not reached by a timing clock
Related violations: <none>

XDCB-5#1 Warning
Runtime inefficient way to find pin objects  
The option '-from : [get_pins -hierarchical -filter {NAME =~ *ila_core_inst/u_trig/N_DDR_TC.N_DDR_TC_INST[*].U_TC/allx_typeA_match_detection.ltlib_v1_0_2_allx_typeA_inst/DUT/u_srl_drive/CLK}]' of constraint 'set_false_path' uses inefficient query to find pin objects (see constraint position '124' in the Timing Constraint window in Vivado IDE). To reduce runtime, it is recommended to get the pins through the cell objects. Please refer to Using Constraints Guide (Constraints Efficiency). An example of optimal query is: get_pins -filter {REF_PIN_NAME=~yy*} -of_objects [get_cells -hierarchical xx*].
Current XDC: /home/henry7090/Desktop/Project/aquila_mp/multicore_aquila/multicore_aquila.runs/impl_1/.Xil/Vivado-258569-henry7090-ROG-Zephyrus-G16/u_ila_0_CV.0/out/ila_early.xdc (Line: 72)
Related violations: <none>

XDCB-5#2 Warning
Runtime inefficient way to find pin objects  
The option '-to : [get_pins -hier -include_replicated_objects -filter {NAME =~ *temp_mon_enabled.u_tempmon/device_temp_sync_r1_reg[*]/D}]' of constraint 'set_max_delay' uses inefficient query to find pin objects (see constraint position '8' in the Timing Constraint window in Vivado IDE). To reduce runtime, it is recommended to get the pins through the cell objects. Please refer to Using Constraints Guide (Constraints Efficiency). An example of optimal query is: get_pins -filter {REF_PIN_NAME=~yy*} -of_objects [get_cells -hierarchical xx*].
Current XDC: /home/henry7090/Desktop/Project/aquila_mp/multicore_aquila/multicore_aquila.gen/sources_1/ip/mig_7series_0/mig_7series_0/user_design/constraints/mig_7series_0.xdc (Line: 356)
Related violations: <none>

XDCB-5#3 Warning
Runtime inefficient way to find pin objects  
The option '-to : [get_pins -hierarchical -filter {NAME =~ *ila_core_inst/u_trig/N_DDR_TC.N_DDR_TC_INST[*].U_TC/yes_output_reg.dout_reg_reg/D}]' of constraint 'set_false_path' uses inefficient query to find pin objects (see constraint position '124' in the Timing Constraint window in Vivado IDE). To reduce runtime, it is recommended to get the pins through the cell objects. Please refer to Using Constraints Guide (Constraints Efficiency). An example of optimal query is: get_pins -filter {REF_PIN_NAME=~yy*} -of_objects [get_cells -hierarchical xx*].
Current XDC: /home/henry7090/Desktop/Project/aquila_mp/multicore_aquila/multicore_aquila.runs/impl_1/.Xil/Vivado-258569-henry7090-ROG-Zephyrus-G16/u_ila_0_CV.0/out/ila_early.xdc (Line: 72)
Related violations: <none>

LATCH-1#1 Advisory
Existing latches in the design  
There are 22 latches found in the design. Inferred latches are often the result of HDL coding mistakes, such as incomplete if or case statements.
Related violations: <none>

REQP-1959#1 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[1].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#2 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[2].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#3 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[3].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#4 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[4].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#5 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[5].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#6 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[6].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#7 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[7].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#8 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_C.ddr_byte_lane_C/ddr_byte_group_io/input_[8].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#9 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[1].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#10 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[2].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#11 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[3].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#12 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[4].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#13 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[5].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#14 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[6].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#15 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[7].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>

REQP-1959#16 Advisory
connects_SERDES_RST_driver_not_FF  
MIG/u_mig_7series_0_mig/u_memc_ui_top_std/mem_intfc0/ddr_phy_top0/u_ddr_mc_phy_wrapper/u_ddr_mc_phy/ddr_phy_4lanes_0.u_ddr_phy_4lanes/ddr_byte_lane_D.ddr_byte_lane_D/ddr_byte_group_io/input_[8].iserdes_dq_.iserdesdq: The RST pin should only be driven by a Flip-flop.
Related violations: <none>


